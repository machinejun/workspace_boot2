
- 자료구조

1. Array
: 인덱스를 통한 셀안에 데이터 접근

장
- 정렬 용이
- 효율적 탐색
단
- 메모리 크기 고정
- 데이터 추가/삭제/정렬 방식 비효율

//
2. 스택(Stack)
: 순서가 보존되는 선형 데이터 구조 유형
: LIFO( last in Fist out ) 메커니즘  =  접시가 쌓일때도 맨 위에 쌓이고 가져갈 때도 맨 위에서만 가져갈수 있다.

장
- 동적 메모리 크기
- 입력받은 순서대로 정렬
- 빠른 런타임

단
- 가장 최신 요소만 가져온다
- 한번에 하나의 데이터만 처리 가능

//
3. 큐(Queue)
: FIFO( first in first out ) 메커니즘 = 데이터가 맨 끝에 저장되고 가져올 때도 가장 처음 저장된 것만 가져올 수 있다.

장
- 스택과 동일
단
- 가장 오래된 요소만 가져온다.
- 한번에 하나의 데이터만 처리 가능

//
4. 연결 리스트(Linked list)
: 물리적 배치를 사용하지 X -> 노드를 통한 연결 : 각 요소의 노드가 저장되고 다음 노드 연결에 대한 포인터(주소)가 또다른 노드에 저장되면서 연결

장
- 데이터 추가 및 삭제시 재구성이 필요 없어 효율적이다.
- 동적인 메모리 크기
- 메모리 효율적 사용 > 대용량 데이터 처리 적합
단
- 처음부터 끝까지 순회해서 원하는 값을 가져오기 때문에 = 비효율적 검색
- 배열보다 더 큰 메모리를 사용

5. 해쉬 테이블(hash 테이블)
: 대용량의 정보를 저장 > 효율적으로 검색할 수 있는 키( 해쉬 함수를 통해서 특정 숫자값으로 반환 )를 제공
: 데이터 구조 > 버킷( key / value ) 형식으로 저장

장
- 추가 삭제 용이
- 검색 효율적
- 동적 메모리
단
- 충돌 빈번

//
6. 그래프
: 노드 사이에 엣지가 있는 컬렉션
: 비선형 구조

장
- 추가/삭제 효율적
- 구조 응용 가능
단
- 충돌

//
7. 트리(Tree)
: 노드로 구성된 계층적 자료구조
: 최상위 노드(루트)를 만들고 > 루트 아래에 child를 추가 > child에 child를 추가하는 형식 > 자식이 없는 노드(leaf)


 